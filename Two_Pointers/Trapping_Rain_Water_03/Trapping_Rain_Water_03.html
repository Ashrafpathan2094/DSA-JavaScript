<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trapping Rain Water ‚Äî DSA Notes</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&family=Cabinet+Grotesk:wght@400;500;700;800&display=swap");

      :root {
        --bg: #05080f;
        --surface: #0c1120;
        --surface2: #111828;
        --border: #1e2a40;
        --accent: #38bdf8;
        --water: #0ea5e9;
        --water-light: #7dd3fc;
        --water-dark: #0369a1;
        --wall: #94a3b8;
        --left-ptr: #f472b6;
        --right-ptr: #a78bfa;
        --maxl: #fb923c;
        --maxr: #34d399;
        --text: #cbd5e1;
        --muted: #475569;
        --code-bg: #080d18;
        --match: #38bdf840;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background: var(--bg);
        color: var(--text);
        font-family: "Cabinet Grotesk", sans-serif;
        min-height: 100vh;
        padding: 40px 20px 80px;
      }

      .page {
        max-width: 960px;
        margin: 0 auto;
      }

      /* HEADER */
      .header {
        margin-bottom: 52px;
        position: relative;
      }
      .header::before {
        content: "RAIN WATER";
        position: absolute;
        top: -10px;
        left: -4px;
        font-size: clamp(60px, 12vw, 120px);
        font-weight: 800;
        color: #ffffff04;
        letter-spacing: -4px;
        pointer-events: none;
        white-space: nowrap;
      }
      .header .tag {
        font-family: "IBM Plex Mono", monospace;
        font-size: 10px;
        color: var(--accent);
        letter-spacing: 4px;
        text-transform: uppercase;
        margin-bottom: 10px;
      }
      .header h1 {
        font-size: clamp(30px, 6vw, 56px);
        font-weight: 800;
        color: #fff;
        line-height: 1.05;
      }
      .header .meta {
        margin-top: 16px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .badge {
        font-family: "IBM Plex Mono", monospace;
        font-size: 10px;
        padding: 4px 10px;
        border-radius: 4px;
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .badge.blue {
        border-color: var(--accent);
        color: var(--accent);
      }
      .badge.pink {
        border-color: var(--left-ptr);
        color: var(--left-ptr);
      }
      .badge.green {
        border-color: var(--maxr);
        color: var(--maxr);
      }

      /* SECTION */
      section {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 30px 34px;
        margin-bottom: 24px;
        animation: rise 0.5s ease both;
      }
      section:nth-child(2) {
        animation-delay: 0.05s;
      }
      section:nth-child(3) {
        animation-delay: 0.1s;
      }
      section:nth-child(4) {
        animation-delay: 0.15s;
      }
      section:nth-child(5) {
        animation-delay: 0.2s;
      }
      section:nth-child(6) {
        animation-delay: 0.25s;
      }
      section:nth-child(7) {
        animation-delay: 0.3s;
      }
      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .sec-label {
        font-family: "IBM Plex Mono", monospace;
        font-size: 10px;
        color: var(--muted);
        letter-spacing: 3px;
        text-transform: uppercase;
        margin-bottom: 12px;
      }
      h2 {
        font-size: 22px;
        font-weight: 800;
        color: #fff;
        margin-bottom: 18px;
      }
      p {
        line-height: 1.75;
        font-size: 15px;
        color: var(--text);
        margin-bottom: 10px;
      }
      p:last-child {
        margin-bottom: 0;
      }
      code {
        font-family: "IBM Plex Mono", monospace;
        background: var(--code-bg);
        border: 1px solid var(--border);
        padding: 2px 7px;
        border-radius: 4px;
        font-size: 12px;
        color: var(--accent);
      }

      /* CARDS */
      .cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 14px;
      }
      .card {
        background: var(--surface2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 18px 20px;
        transition: border-color 0.2s;
      }
      .card:hover {
        border-color: var(--accent);
      }
      .card .icon {
        font-size: 24px;
        margin-bottom: 10px;
      }
      .card h3 {
        font-size: 13px;
        font-weight: 700;
        color: #fff;
        margin-bottom: 6px;
      }
      .card p {
        font-size: 13px;
        margin: 0;
        color: var(--muted);
      }

      /* CODE BLOCK */
      .code-block {
        background: var(--code-bg);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 22px 24px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 13px;
        line-height: 1.9;
        overflow-x: auto;
        counter-reset: ln;
      }
      .code-block .line {
        display: block;
        position: relative;
        padding-left: 38px;
        white-space: pre;
      }
      .code-block .line::before {
        counter-increment: ln;
        content: counter(ln);
        position: absolute;
        left: 0;
        color: var(--muted);
        width: 26px;
        text-align: right;
        font-size: 11px;
        opacity: 0.5;
      }
      .kw {
        color: #c084fc;
      }
      .fn {
        color: #60a5fa;
      }
      .str {
        color: var(--maxr);
      }
      .nm {
        color: var(--maxl);
      }
      .cm {
        color: #334155;
        font-style: italic;
      }
      .hl {
        background: #38bdf810;
        border-radius: 3px;
      }

      /* ‚ïê‚ïê‚ïê VISUALIZATION ‚ïê‚ïê‚ïê */
      .viz-wrap {
        background: var(--code-bg);
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
      }
      .viz-toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid var(--border);
        flex-wrap: wrap;
      }
      .viz-toolbar label {
        font-family: "IBM Plex Mono", monospace;
        font-size: 11px;
        color: var(--muted);
      }
      .viz-input {
        font-family: "IBM Plex Mono", monospace;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: #fff;
        padding: 6px 12px;
        font-size: 12px;
        width: 280px;
        outline: none;
        transition: border-color 0.2s;
      }
      .viz-input:focus {
        border-color: var(--accent);
      }
      .btn {
        font-family: "Cabinet Grotesk", sans-serif;
        font-weight: 700;
        font-size: 12px;
        padding: 7px 16px;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        transition: all 0.15s;
      }
      .btn-blue {
        background: var(--accent);
        color: #05080f;
      }
      .btn-blue:hover {
        background: var(--water-light);
      }
      .btn-ghost {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .btn-ghost:hover {
        border-color: var(--accent);
        color: var(--accent);
      }
      .btn-ghost:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      /* CANVAS CONTAINER */
      .canvas-area {
        padding: 24px;
      }
      canvas#rainCanvas {
        display: block;
        width: 100%;
        border-radius: 8px;
        image-rendering: -webkit-optimize-contrast;
      }

      /* STEP PANEL */
      .step-panel {
        margin: 0 20px 20px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 16px 20px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 13px;
        line-height: 1.9;
        min-height: 90px;
      }
      .sp-row {
        display: flex;
        gap: 24px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .sp-item {
        display: flex;
        align-items: center;
        gap: 7px;
      }
      .sp-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      .sp-label {
        font-size: 11px;
        color: var(--muted);
      }
      .sp-val {
        font-size: 13px;
        color: #fff;
        font-weight: 600;
      }
      .sp-msg {
        font-size: 13px;
        color: var(--text);
        line-height: 1.6;
      }
      .sp-msg .good {
        color: var(--maxr);
        font-weight: 700;
      }
      .sp-msg .step-n {
        color: var(--accent);
      }
      .sp-msg .ptr-l {
        color: var(--left-ptr);
      }
      .sp-msg .ptr-r {
        color: var(--right-ptr);
      }
      .sp-msg .wtr {
        color: var(--water-light);
      }

      /* NAV BAR */
      .nav-bar {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 14px 20px;
        border-top: 1px solid var(--border);
        flex-wrap: wrap;
      }
      .step-counter {
        font-family: "IBM Plex Mono", monospace;
        font-size: 11px;
        color: var(--muted);
        margin-left: auto;
      }
      .speed-sel {
        font-family: "IBM Plex Mono", monospace;
        background: var(--surface);
        border: 1px solid var(--border);
        color: var(--muted);
        border-radius: 6px;
        padding: 5px 10px;
        font-size: 11px;
        cursor: pointer;
      }

      /* TOTAL WATER BADGE */
      .total-water {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: #0ea5e918;
        border: 1px solid var(--water-dark);
        color: var(--water-light);
        border-radius: 8px;
        padding: 6px 14px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 13px;
        margin-top: 12px;
        min-width: 120px;
      }
      .total-water .val {
        font-size: 20px;
        font-weight: 700;
        color: #fff;
      }

      /* COMPLEXITY */
      .cplx-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      .cplx-card {
        background: var(--surface2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 22px;
        text-align: center;
      }
      .cplx-val {
        font-family: "IBM Plex Mono", monospace;
        font-size: 30px;
        font-weight: 700;
        color: var(--accent);
        margin-bottom: 4px;
      }
      .cplx-lbl {
        font-size: 13px;
        color: var(--muted);
        line-height: 1.5;
      }

      /* PITFALLS */
      .pitfall {
        display: flex;
        gap: 16px;
        padding: 16px 0;
        border-bottom: 1px solid var(--border);
      }
      .pitfall:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }
      .p-num {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: var(--left-ptr);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        font-weight: 700;
        flex-shrink: 0;
      }
      .pitfall h4 {
        font-size: 14px;
        color: #fff;
        margin-bottom: 4px;
      }
      .pitfall p {
        font-size: 13px;
        color: var(--muted);
        margin: 0;
      }

      /* LEGEND */
      .legend {
        display: flex;
        gap: 18px;
        flex-wrap: wrap;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border);
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 7px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 10px;
        color: var(--muted);
      }
      .legend-swatch {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }

      @media (max-width: 600px) {
        section {
          padding: 20px 18px;
        }
        .cplx-grid {
          grid-template-columns: 1fr 1fr;
        }
        .viz-input {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <!-- HEADER -->
      <div class="header">
        <div class="tag">DSA Revision Notes</div>
        <h1>Trapping Rain Water</h1>
        <div class="meta">
          <span class="badge blue">LeetCode #42</span>
          <span class="badge pink">Two Pointers</span>
          <span class="badge green">O(n) Time ¬∑ O(1) Space</span>
          <span class="badge">Classic Hard</span>
        </div>
      </div>

      <!-- PROBLEM -->
      <section>
        <div class="sec-label">01 / Problem</div>
        <h2>What are we solving?</h2>
        <p>
          Given an array <code>height</code> where each element represents the
          height of a bar in a histogram, compute how much rainwater can be
          trapped between the bars after it rains.
        </p>
        <p>
          Water above a bar at index <code>i</code> equals:
          <code>min(maxLeft, maxRight) ‚àí height[i]</code>. The key insight is
          that water level is dictated by the <em>shorter</em> of the two
          tallest walls on either side.
        </p>
      </section>

      <!-- INTUITION -->
      <section>
        <div class="sec-label">02 / Intuition</div>
        <h2>Why Two Pointers Work</h2>
        <div class="cards">
          <div class="card">
            <div class="icon">üéØ</div>
            <h3>Process the Shorter Side</h3>
            <p>
              If <code>maxLeft ‚â§ maxRight</code>, the left side is the
              bottleneck ‚Äî move left pointer in. Water there is guaranteed by
              <code>maxRight</code> being taller.
            </p>
          </div>
          <div class="card">
            <div class="icon">üèîÔ∏è</div>
            <h3>Max Walls = Water Level</h3>
            <p>
              At any bar, water = <code>max_of_shorter_wall ‚àí bar_height</code>.
              We don't need to know the exact right wall ‚Äî just that it's ‚â•
              maxLeft.
            </p>
          </div>
          <div class="card">
            <div class="icon">üîÑ</div>
            <h3>Inward Convergence</h3>
            <p>
              Left and right pointers move toward each other. Each step adds
              water for one bar. We stop when they meet.
            </p>
          </div>
          <div class="card">
            <div class="icon">‚úÖ</div>
            <h3>No Extra Array</h3>
            <p>
              Classic DP uses two O(n) arrays for left/right maxes. Two pointers
              compute the same result in O(1) space by tracking running maxes.
            </p>
          </div>
        </div>
      </section>

      <!-- CODE -->
      <section>
        <div class="sec-label">03 / Annotated Code</div>
        <h2>Two-Pointer Solution</h2>
        <div class="code-block">
          <span class="line"
            ><span class="kw">const</span> <span class="fn">trap</span> =
            (height) => {</span
          >
          <span class="line">
            <span class="kw">let</span> water = <span class="nm">0</span>;
            <span class="cm">// accumulated rainwater</span></span
          >
          <span class="line">
            <span class="kw">let</span> leftIndex = <span class="nm">0</span>;
            <span class="cm">// left pointer starts at 0</span></span
          >
          <span class="line">
            <span class="kw">let</span> rightIndex = height.length -
            <span class="nm">1</span>;
            <span class="cm">// right pointer starts at end</span></span
          >
          <span class="line">
            <span class="kw">let</span> maxLeft = height[leftIndex];
            <span class="cm">// running max from the left</span></span
          >
          <span class="line">
            <span class="kw">let</span> maxRight = height[rightIndex];
            <span class="cm">// running max from the right</span></span
          >
          <span class="line"></span>
          <span class="line">
            <span class="kw">while</span> (leftIndex != rightIndex) {</span
          >
          <span class="line">
            <span class="kw">if</span> (height[leftIndex] > height[rightIndex])
            { <span class="cm">// right side is the bottleneck</span></span
          >
          <span class="line">
            rightIndex--;
            <span class="cm">// move right pointer inward</span></span
          >
          <span class="line">
            <span class="hl"
              >maxRight = Math.<span class="fn">max</span>(maxRight,
              height[rightIndex]);</span
            >
            <span class="cm">// update right max</span></span
          >
          <span class="line">
            <span class="hl"
              >water = water + maxRight - height[rightIndex];</span
            >
            <span class="cm">// water this bar can hold</span></span
          >
          <span class="line">
            } <span class="kw">else</span> {
            <span class="cm"
              >// left side is the bottleneck (or equal)</span
            ></span
          >
          <span class="line">
            leftIndex++;
            <span class="cm">// move left pointer inward</span></span
          >
          <span class="line">
            <span class="hl"
              >maxLeft = Math.<span class="fn">max</span>(maxLeft,
              height[leftIndex]);</span
            >
            <span class="cm">// update left max</span></span
          >
          <span class="line">
            <span class="hl">water = water + maxLeft - height[leftIndex];</span>
            <span class="cm">// water this bar can hold</span></span
          >
          <span class="line"> }</span>
          <span class="line"> }</span>
          <span class="line"> <span class="kw">return</span> water;</span>
          <span class="line">};</span>
        </div>
      </section>

      <!-- VISUALIZATION -->
      <section>
        <div class="sec-label">04 / Interactive Visualization</div>
        <h2>Watch the Algorithm Run</h2>
        <div class="viz-wrap">
          <!-- Toolbar -->
          <div class="viz-toolbar">
            <label>heights =&nbsp;</label>
            <input
              class="viz-input"
              id="hInput"
              value="0,1,0,2,1,0,1,3,2,1,2,1"
              placeholder="comma-separated, e.g. 4,2,0,3,2,5"
            />
            <button class="btn btn-blue" onclick="initViz()">‚ñ∂ Run</button>
          </div>

          <!-- Legend -->
          <div class="legend">
            <div class="legend-item">
              <div class="legend-swatch" style="background: #94a3b8"></div>
              Bar
            </div>
            <div class="legend-item">
              <div
                class="legend-swatch"
                style="background: #0ea5e990; border: 1px solid #38bdf8"
              ></div>
              Trapped Water
            </div>
            <div class="legend-item">
              <div
                class="legend-swatch"
                style="background: var(--left-ptr)"
              ></div>
              Left Pointer (L)
            </div>
            <div class="legend-item">
              <div
                class="legend-swatch"
                style="background: var(--right-ptr)"
              ></div>
              Right Pointer (R)
            </div>
            <div class="legend-item">
              <div class="legend-swatch" style="background: var(--maxl)"></div>
              maxLeft line
            </div>
            <div class="legend-item">
              <div class="legend-swatch" style="background: var(--maxr)"></div>
              maxRight line
            </div>
          </div>

          <!-- Canvas -->
          <div class="canvas-area">
            <canvas id="rainCanvas" height="300"></canvas>
          </div>

          <!-- Total water display -->
          <div
            style="
              padding: 0 20px 16px;
              display: flex;
              align-items: center;
              gap: 16px;
              flex-wrap: wrap;
            "
          >
            <div class="total-water">
              üíß Total water: <span class="val" id="totalWaterVal">‚Äî</span>
            </div>
          </div>

          <!-- Step info panel -->
          <div class="step-panel" id="stepPanel">
            <div class="sp-msg">
              Press <strong>Run</strong> to begin the simulation.
            </div>
          </div>

          <!-- Nav -->
          <div class="nav-bar">
            <button
              class="btn btn-ghost"
              id="btnPrev"
              onclick="prevStep()"
              disabled
            >
              ‚óÄ Prev
            </button>
            <button
              class="btn btn-ghost"
              id="btnNext"
              onclick="nextStep()"
              disabled
            >
              Next ‚ñ∂
            </button>
            <button class="btn btn-ghost" id="btnAuto" onclick="toggleAuto()">
              ‚ñ∂‚ñ∂ Auto
            </button>
            <select class="speed-sel" id="speedSel">
              <option value="900">Slow</option>
              <option value="500" selected>Normal</option>
              <option value="200">Fast</option>
            </select>
            <span class="step-counter" id="stepCounter">‚Äî</span>
          </div>
        </div>
      </section>

      <!-- COMPLEXITY -->
      <section>
        <div class="sec-label">05 / Complexity</div>
        <h2>Time &amp; Space</h2>
        <div class="cplx-grid">
          <div class="cplx-card">
            <div class="cplx-val">O(n)</div>
            <div class="cplx-lbl">
              Time ‚Äî each element is visited at most once as pointers converge
            </div>
          </div>
          <div class="cplx-card">
            <div class="cplx-val">O(1)</div>
            <div class="cplx-lbl">
              Space ‚Äî only 4 variables: water, leftIndex, rightIndex, maxLeft,
              maxRight
            </div>
          </div>
        </div>
      </section>

      <!-- PITFALLS -->
      <section>
        <div class="sec-label">06 / Watch Out For</div>
        <h2>Common Mistakes</h2>
        <div class="pitfall">
          <div class="p-num">1</div>
          <div>
            <h4>Move pointer THEN update max</h4>
            <p>
              The pointer moves first (<code>rightIndex--</code> or
              <code>leftIndex++</code>), and only then we update
              <code>maxRight</code>/<code>maxLeft</code> and accumulate water
              for the new position. Getting this order wrong produces wrong
              results.
            </p>
          </div>
        </div>
        <div class="pitfall">
          <div class="p-num">2</div>
          <div>
            <h4>The bottleneck rule</h4>
            <p>
              Process the side with the <em>shorter current bar height</em> ‚Äî
              not the shorter max. We compare <code>height[leftIndex]</code> vs
              <code>height[rightIndex]</code>, not <code>maxLeft</code> vs
              <code>maxRight</code>.
            </p>
          </div>
        </div>
        <div class="pitfall">
          <div class="p-num">3</div>
          <div>
            <h4>Water can be 0 at tall bars</h4>
            <p>
              When a bar equals the current max,
              <code>maxHeight ‚àí bar = 0</code>. That's correct ‚Äî you add 0
              water. Don't skip these bars; the pointer still needs to move.
            </p>
          </div>
        </div>
        <div class="pitfall">
          <div class="p-num">4</div>
          <div>
            <h4>The equal case goes to <code>else</code></h4>
            <p>
              When <code>height[left] === height[right]</code>, both paths are
              valid. The code uses the <code>else</code> branch (left pointer
              moves). Either works correctly due to the symmetric nature of the
              problem.
            </p>
          </div>
        </div>
      </section>
    </div>
    <!-- .page -->

    <script>
      // ‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let steps = [];
      let cur = 0;
      let autoTimer = null;

      // ‚ïê‚ïê‚ïê STEP BUILDER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function buildSteps(height) {
        const steps = [];
        let water = 0;
        let L = 0,
          R = height.length - 1;
        let mL = height[0],
          mR = height[R];

        // Snapshot the "water trapped per bar" array as we go
        const waterAt = new Array(height.length).fill(0);

        steps.push({
          L,
          R,
          mL,
          mR,
          water,
          waterAt: [...waterAt],
          active: -1,
          side: null,
          added: 0,
          msg: `Init: L=${L}, R=${R}, maxLeft=${mL}, maxRight=${mR}. Start sliding pointers inward.`,
          done: false,
        });

        while (L !== R) {
          let side,
            added = 0;
          if (height[L] > height[R]) {
            side = "right";
            R--;
            mR = Math.max(mR, height[R]);
            added = mR - height[R];
            waterAt[R] = added;
            water += added;
          } else {
            side = "left";
            L++;
            mL = Math.max(mL, height[L]);
            added = mL - height[L];
            waterAt[L] = added;
            water += added;
          }
          const active = side === "left" ? L : R;
          steps.push({
            L,
            R,
            mL,
            mR,
            water,
            waterAt: [...waterAt],
            active,
            side,
            added,
            msg: buildMsg(height, L, R, mL, mR, side, active, added, water),
            done: false,
          });
        }

        // Final state
        steps.push({
          L,
          R,
          mL,
          mR,
          water,
          waterAt: [...waterAt],
          active: -1,
          side: null,
          added: 0,
          msg: `‚úÖ Pointers met at index ${L}. Total trapped water = ${water} units.`,
          done: true,
        });

        return steps;
      }

      function buildMsg(height, L, R, mL, mR, side, active, added, water) {
        const arrow = side === "left" ? "‚Üí L" : "R ‚Üê";
        const ptr = side === "left" ? `L=${L}` : `R=${R}`;
        const mx = side === "left" ? `maxLeft=${mL}` : `maxRight=${mR}`;
        return (
          `${arrow} Moved ${side} pointer. ${ptr}, ${mx}, height[${active}]=${height[active]}. ` +
          `Water here = ${added >= 0 ? added : 0}. Running total = ${water}.`
        );
      }

      // ‚ïê‚ïê‚ïê CANVAS RENDERER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let animFrame = null;
      let renderTarget = null; // the step we're animating toward
      let animProg = 1; // 0‚Üí1 animation progress
      let prevState = null;

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      function easeOut(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function drawViz(step, progress = 1) {
        const canvas = document.getElementById("rainCanvas");
        const dpr = window.devicePixelRatio || 1;
        const displayW = canvas.parentElement.clientWidth - 48;
        const displayH = 300;
        canvas.style.width = displayW + "px";
        canvas.style.height = displayH + "px";
        canvas.width = displayW * dpr;
        canvas.height = displayH * dpr;
        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        const W = displayW,
          H = displayH;
        const height = step._height;
        const n = height.length;

        // Layout
        const PAD_L = 14,
          PAD_R = 14,
          PAD_TOP = 48,
          PAD_BOT = 36;
        const chartW = W - PAD_L - PAD_R;
        const chartH = H - PAD_TOP - PAD_BOT;
        const maxH = Math.max(...height, 1);
        const barW = chartW / n;
        const unitH = chartH / (maxH + 1);

        // Clear
        ctx.clearRect(0, 0, W, H);

        // Grid lines
        ctx.strokeStyle = "#1e2a40";
        ctx.lineWidth = 0.5;
        for (let g = 0; g <= maxH + 1; g++) {
          const y = PAD_TOP + chartH - g * unitH;
          ctx.beginPath();
          ctx.moveTo(PAD_L, y);
          ctx.lineTo(W - PAD_R, y);
          ctx.stroke();
        }

        const t = easeOut(progress);

        // Draw water (animated fill rising)
        for (let i = 0; i < n; i++) {
          if (step.waterAt[i] > 0) {
            const x = PAD_L + i * barW;
            const barPx = height[i] * unitH;
            const waterPx = step.waterAt[i] * unitH * t;
            const y = PAD_TOP + chartH - barPx - waterPx;

            // Water gradient
            const grad = ctx.createLinearGradient(x, y, x, y + waterPx);
            grad.addColorStop(0, "#38bdf870");
            grad.addColorStop(1, "#0ea5e9b0");
            ctx.fillStyle = grad;
            ctx.fillRect(x + 1, y, barW - 2, waterPx);

            // Water shimmer line
            ctx.strokeStyle = "#7dd3fc60";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x + 1, y);
            ctx.lineTo(x + barW - 1, y);
            ctx.stroke();
          }
        }

        // Draw bars
        for (let i = 0; i < n; i++) {
          const x = PAD_L + i * barW;
          const bh = height[i] * unitH;
          const y = PAD_TOP + chartH - bh;

          // Highlight active bar
          if (i === step.active && t > 0.2) {
            ctx.fillStyle = step.side === "left" ? "#f472b630" : "#a78bfa30";
            ctx.fillRect(x, PAD_TOP, barW, chartH);
          }

          // Bar gradient
          const isL = i === step.L;
          const isR = i === step.R;
          const baseColor = isL ? "#f472b6" : isR ? "#a78bfa" : "#475569";
          const lightColor = isL ? "#fbcfe8" : isR ? "#ddd6fe" : "#94a3b8";

          const grad = ctx.createLinearGradient(x, y, x + barW, y);
          grad.addColorStop(0, lightColor);
          grad.addColorStop(1, baseColor);
          ctx.fillStyle = grad;
          ctx.fillRect(x + 1, y, barW - 2, bh);

          // Bar top border
          ctx.fillStyle = lightColor;
          ctx.fillRect(x + 1, y, barW - 2, 2);
        }

        // maxLeft dashed line
        if (step.mL > 0) {
          const y = PAD_TOP + chartH - step.mL * unitH;
          ctx.setLineDash([5, 4]);
          ctx.strokeStyle = "#fb923c";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(PAD_L, y);
          ctx.lineTo(PAD_L + (step.L + 1) * barW, y);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = "#fb923c";
          ctx.font = "bold 10px IBM Plex Mono, monospace";
          ctx.fillText(`mL=${step.mL}`, PAD_L + 2, y - 4);
        }

        // maxRight dashed line
        if (step.mR > 0) {
          const y = PAD_TOP + chartH - step.mR * unitH;
          ctx.setLineDash([5, 4]);
          ctx.strokeStyle = "#34d399";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(PAD_L + step.R * barW, y);
          ctx.lineTo(W - PAD_R, y);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = "#34d399";
          ctx.font = "bold 10px IBM Plex Mono, monospace";
          const lbl = `mR=${step.mR}`;
          const tw = ctx.measureText(lbl).width;
          ctx.fillText(lbl, W - PAD_R - tw - 2, y - 4);
        }

        // Pointer labels (L / R) above bars
        ctx.font = "bold 12px IBM Plex Mono, monospace";
        // L
        const lx = PAD_L + step.L * barW + barW / 2;
        ctx.fillStyle = "#f472b6";
        ctx.textAlign = "center";
        const lBarTop = PAD_TOP + chartH - height[step.L] * unitH;
        const lWaterTop =
          step.waterAt[step.L] > 0
            ? lBarTop - step.waterAt[step.L] * unitH * t
            : lBarTop;
        ctx.fillText("L", lx, lWaterTop - 8);
        // R
        if (step.R !== step.L) {
          const rx = PAD_L + step.R * barW + barW / 2;
          ctx.fillStyle = "#a78bfa";
          const rBarTop = PAD_TOP + chartH - height[step.R] * unitH;
          const rWaterTop =
            step.waterAt[step.R] > 0
              ? rBarTop - step.waterAt[step.R] * unitH * t
              : rBarTop;
          ctx.fillText("R", rx, rWaterTop - 8);
        }

        // Index labels at bottom
        ctx.fillStyle = "#334155";
        ctx.font = "10px IBM Plex Mono, monospace";
        ctx.textAlign = "center";
        for (let i = 0; i < n; i++) {
          const x = PAD_L + i * barW + barW / 2;
          ctx.fillText(i, x, H - PAD_BOT + 14);
        }

        // Height labels inside bars
        ctx.font = "10px IBM Plex Mono, monospace";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        for (let i = 0; i < n; i++) {
          if (height[i] > 0) {
            const x = PAD_L + i * barW + barW / 2;
            const y = PAD_TOP + chartH - height[i] * unitH + 12;
            ctx.fillText(height[i], x, y);
          }
        }

        ctx.textAlign = "left";
      }

      function animateStep() {
        if (!renderTarget) return;
        animProg += 0.05;
        if (animProg >= 1) {
          animProg = 1;
          drawViz(renderTarget, 1);
          renderTarget = null;
          return;
        }
        drawViz(renderTarget, animProg);
        animFrame = requestAnimationFrame(animateStep);
      }

      function showStep(idx, animate = true) {
        if (!steps.length) return;
        idx = Math.max(0, Math.min(steps.length - 1, idx));
        cur = idx;

        const step = { ...steps[cur], _height: window._vizHeight };
        renderTarget = step;
        animProg = animate ? 0 : 1;
        cancelAnimationFrame(animFrame);
        animateStep();

        // Panel
        const panel = document.getElementById("stepPanel");
        const s = steps[cur];
        panel.innerHTML = `
    <div class="sp-row">
      <div class="sp-item"><div class="sp-dot" style="background:var(--left-ptr)"></div><span class="sp-label">L =</span><span class="sp-val">${s.L}</span></div>
      <div class="sp-item"><div class="sp-dot" style="background:var(--right-ptr)"></div><span class="sp-label">R =</span><span class="sp-val">${s.R}</span></div>
      <div class="sp-item"><div class="sp-dot" style="background:var(--maxl)"></div><span class="sp-label">maxLeft =</span><span class="sp-val">${s.mL}</span></div>
      <div class="sp-item"><div class="sp-dot" style="background:var(--maxr)"></div><span class="sp-label">maxRight =</span><span class="sp-val">${s.mR}</span></div>
      <div class="sp-item"><div class="sp-dot" style="background:var(--water)"></div><span class="sp-label">water =</span><span class="sp-val">${s.water}</span></div>
    </div>
    <div class="sp-msg">${formatMsg(s)}</div>`;

        // Total water
        document.getElementById("totalWaterVal").textContent = s.done
          ? s.water
          : "‚Ä¶";

        // Counter
        document.getElementById("stepCounter").textContent =
          `Step ${cur + 1} / ${steps.length}`;

        // Buttons
        document.getElementById("btnPrev").disabled = cur === 0;
        document.getElementById("btnNext").disabled = cur === steps.length - 1;
      }

      function formatMsg(s) {
        if (!s.msg) return "";
        return s.msg
          .replace(/‚úÖ/g, '<span class="good">‚úÖ</span>')
          .replace(/L=(\d+)/g, '<span class="ptr-l">L=$1</span>')
          .replace(/R=(\d+)/g, '<span class="ptr-r">R=$1</span>')
          .replace(/water = (\d+)/g, '<span class="wtr">water = $1</span>')
          .replace(/total = (\d+)/g, '<span class="wtr">total = $1</span>')
          .replace(/= (\d+) units/g, '= <span class="good">$1 units</span>');
      }

      function initViz() {
        clearInterval(autoTimer);
        autoTimer = null;
        document.getElementById("btnAuto").textContent = "‚ñ∂‚ñ∂ Auto";

        const raw = document.getElementById("hInput").value;
        const height = raw
          .split(",")
          .map((v) => parseInt(v.trim()))
          .filter((v) => !isNaN(v) && v >= 0);
        if (height.length < 2) {
          document.getElementById("stepPanel").innerHTML =
            '<div class="sp-msg" style="color:var(--left-ptr)">Please enter at least 2 non-negative integers.</div>';
          return;
        }
        window._vizHeight = height;
        steps = buildSteps(height);
        document.getElementById("btnNext").disabled = false;
        showStep(0, false);
      }

      function nextStep() {
        if (cur < steps.length - 1) showStep(cur + 1, true);
      }
      function prevStep() {
        if (cur > 0) showStep(cur - 1, false);
      }
      function toggleAuto() {
        const btn = document.getElementById("btnAuto");
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
          btn.textContent = "‚ñ∂‚ñ∂ Auto";
          return;
        }
        btn.textContent = "‚èπ Stop";
        const speed = parseInt(document.getElementById("speedSel").value);
        autoTimer = setInterval(() => {
          if (cur >= steps.length - 1) {
            clearInterval(autoTimer);
            autoTimer = null;
            btn.textContent = "‚ñ∂‚ñ∂ Auto";
            return;
          }
          showStep(cur + 1, true);
        }, speed);
      }

      // Handle resize
      window.addEventListener("resize", () => {
        if (steps.length && cur < steps.length) {
          const s = { ...steps[cur], _height: window._vizHeight };
          drawViz(s, 1);
        }
      });

      // Init on load
      window.onload = initViz;
    </script>
  </body>
</html>
